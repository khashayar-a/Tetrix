-module(estimation).
-export([findcircle/3, getAng/2, getDistance/2, testCircle/0, testStraight/0, addDashes/4, genDashStraight/2, printDash/2]).

%%x=1000, 987.69, 939.69, 874.62, 766.04, 656.06
%%y=0, 156.43, 342.02, 484.81, 642.73, 754.71

%%{X1,Y1}, {X2,Y2}, {X3,Y3}

-record(dash_line, {center_point, box, points, area, dash_before, dash_after}).

testStraight() ->
	X1 = 200*math:cos(1.0),
	Y1 = 200*math:sin(1.0),
	X2 = 400*math:cos(1.0),
	Y2 = 400*math:sin(1.0),
	X3 = 600*math:cos(1.0),
	Y3 = 600*math:sin(1.0),
	io:format("Points: ~p~n", [[{X1,Y1},{X2,Y2},{X3,Y3}]]),
	
	addDashes({X1,Y1},{X2,Y2},{X3,Y3}, 3).

testCircle()->
	X1 = 500-random:uniform(10000)/10,
	Y1 = 500-random:uniform(10000)/10,
	%%Num = (math:pi()*2),
	Ang = random:uniform(628)/100,
	Ang2 = (random:uniform(52)/100)-(26/100),
	X2 = X1 + 200*math:cos(Ang),
	Y2 = Y1 + 200*math:sin(Ang),
	X3 = X2 + 200*math:cos(Ang+Ang2),
	Y3 = Y2 + 200*math:sin(Ang+Ang2),
	{ok, FileID} = file:open("hello.txt", [read, write,append]),
	io:fwrite(FileID, "~p,~p,~n~p,~p,~n~p,~p,~n~n",[X1, Y1, X2, Y2, X3, Y3]),
	List = addDashes({X1,Y1},{X2,Y2},{X3,Y3}, 3), %% [{OLD,Syntax},{X,Y},{X,Y}]
	
	%%io:fwrite(FileID, "~p,~p,~n~p,~p,~n~p,~p,~n~n",[Xval1, Yval1, Xval2, Yval2, Xval3, Yval3]).
	printDash(List, FileID).
	
printDash([],_FileID) -> ok;
printDash([{{Xc,Yc},{{Xbl,Ybl},{Xtl,Ytl},{Xtr,Ytr},{Xbr,Ybr}},{{Xcb,Ycb},{Xc,Yc},{Xct,Yct}}}|T], FileID) ->
	io:fwrite(FileID, "~p,~p,~n~p,~p,~n~p,~p,~n~p,~p,~n~p,~p,~n~p,~p,~n~p,~p,~n~p,~p,~n~n",
		[Xc, Yc, Xbl, Ybl, Xtl, Ytl, Xtr, Ytr, Xbr, Ybr, Xcb, Ycb, Xc, Yc, Xct, Yct]),
	printDash(T, FileID).
	%% {{Xc,Yc},{{Xbl,Ybl},{Xtl,Ytl},{Xtr,Ytr},{Xbr,Ybr}},{{Xcb,Ycb},{Xc,Yc},{Xct,Yct}}}

addDashes(P1,P2,P3,Amount)->
	Circle = findcircle(P1,P2,P3),
	case Circle of
		{{_CenterX,_CenterY},_Radius,_ClockWise} -> 
			Points = genDashCircle( Circle, {P2,P3}, Amount);
		_ -> Points = genDashStraight({P2, P3}, Amount)
	end,
	Points.
			

genDashStraight({P2, P3}, Amount) ->
	Angel = getAng(P2, P3),
	genDashStraight([], Amount, Angel, P3).

genDashStraight(Points, 0, _Angel, _LastPoint) -> 
	Points;
genDashStraight(Points, Amount, Angel, {XPoint,YPoint}) -> 
	X = XPoint+400*Amount*math:cos(Angel),
	Y = YPoint+400*Amount*math:sin(Angel),
	%%io:format("Straight: ~p~n", [Amount]),
	genDashStraight([{X,Y}|Points], Amount-1, Angel, {XPoint,YPoint}).
	

genDashCircle({{CenterX,CenterY},Radius,ClockWise}, {{Dash1X,Dash1Y},{Dash2X,Dash2Y}}, Amount)->
	Dash1Angel = math:atan2(Dash1Y-CenterY,Dash1X-CenterX),
	Dash2Angel = math:atan2(Dash2Y-CenterY,Dash2X-CenterX),
	genDashCircle([], Amount, Dash2Angel, 	{CenterX,CenterY},Radius,ClockWise).

genDashCircle(Points, 0, _LastPointAngel, {_CenterX,_CenterY},_Radius,_ClockWise)->
	Points;

genDashCircle(Points, Amount, LastPointAngel, {CenterX,CenterY},Radius,ClockWise)->
    Xc = CenterX+Radius*math:cos(LastPointAngel-Amount*(200*ClockWise/Radius)), 
    Yc = CenterY+Radius*math:sin(LastPointAngel-Amount*(200*ClockWise/Radius)),
    Xbl = CenterX+(Radius+(10*ClockWise))*math:cos(LastPointAngel+(100*ClockWise/Radius)-Amount*(200*ClockWise/Radius)), 
    Ybl = CenterY+(Radius+(10*ClockWise))*math:sin(LastPointAngel+(100*ClockWise/Radius)-Amount*(200*ClockWise/Radius)),
    Xtl = CenterX+(Radius+(10*ClockWise))*math:cos(LastPointAngel-(100*ClockWise/Radius)-Amount*(200*ClockWise/Radius)), 
    Ytl = CenterY+(Radius+(10*ClockWise))*math:sin(LastPointAngel-(100*ClockWise/Radius)-Amount*(200*ClockWise/Radius)),
    Xtr = CenterX+(Radius-(10*ClockWise))*math:cos(LastPointAngel-(100*ClockWise/Radius)-Amount*(200*ClockWise/Radius)), 
    Ytr = CenterY+(Radius-(10*ClockWise))*math:sin(LastPointAngel-(100*ClockWise/Radius)-Amount*(200*ClockWise/Radius)),
    Xbr = CenterX+(Radius-(10*ClockWise))*math:cos(LastPointAngel+(100*ClockWise/Radius)-Amount*(200*ClockWise/Radius)), 
    Ybr = CenterY+(Radius-(10*ClockWise))*math:sin(LastPointAngel+(100*ClockWise/Radius)-Amount*(200*ClockWise/Radius)),
    Xcb = CenterX+(Radius)*math:cos(LastPointAngel+(100*ClockWise/Radius)-Amount*(200*ClockWise/Radius)), 
    Ycb = CenterY+(Radius)*math:sin(LastPointAngel+(100*ClockWise/Radius)-Amount*(200*ClockWise/Radius)),
    Xct = CenterX+(Radius)*math:cos(LastPointAngel-(100*ClockWise/Radius)-Amount*(200*ClockWise/Radius)), 
    Yct = CenterY+(Radius)*math:sin(LastPointAngel-(100*ClockWise/Radius)-Amount*(200*ClockWise/Radius)),
    
    %%io:format("Circle: ~p~n", [Amount]),
    Result = #dash_line{center_point = {round(Xc),round(Yc)} , 
			box = {{round(Xbl),round(Ybl)},{round(Xtl),round(Ytl)},
			       {round(Xtr),round(Ytr)},{round(Xbr),round(Ybr)}},
			points = [{round(Xcb),round(Ycb)},
				  {round(Xc),round(Yc)},
				  {round(Xct),round(Yct)}]},
			
    genDashCircle([Result |Points], Amount-1, LastPointAngel, {CenterX,CenterY},Radius,ClockWise).
	
	


findcircle({X1,Y1}, {X2,Y2}, {X3,Y3}) -> 
    %% {X1,Y1} -> {double,double},
    %% {X2,Y2} -> {double,double},
    %% {X3,Y3} -> {double,double},
    %% CarPos = node() -> {X,Y} -> {double,double},
    %% CarHeading = node() -> {X,Y} -> {double,double},
    %% Radius = double,
    %% CenterPoint = node() -> {X,Y} -> {double,double},
    %% Find = {CenterPoint = node() -> {X,Y} , Radius = double},
    %% infinate = {CarPos,CarHeading,P3},
    
    Line1 = ((Y1 - Y2) / (X1 - X2)),
   

    Line2 = ((Y2 - Y3) / (X2 - X3)),
    
    CenterPointX = (Line1*Line2*(Y3-Y1)+ Line1*(X2+X3) - Line2*(X1+X2)) / (2*(Line1-Line2)),
    CenterPointY = -(1/Line1) * (CenterPointX - ((X1+X2)/2)) + (Y1 + Y2) / 2,
    CenterPoint = {CenterPointX,CenterPointY},
    %% #steerCalc{cp = CenterPoint}, 
    Radius = getDistance(CenterPoint, {X1,Y1}),
    %% #steerCalc{radius = Radius},

    Line3 = getAng({X1 , Y1} , {X2 , Y2}),
	%%io:format("Line3: ~p~n", [{Radius,Line2}]),
	
    case Radius > 100000 of 
        true -> 
            infinite;
        false ->
            Line4 = getAng({X2 , Y2} , {X3 , Y3}),        
            case Line2 > 100000 of
                true ->
                    infinite;
                false ->
                    Area = math:cos(Line4+(math:pi()/2-Line3)),
                    Clockwise = Area/(abs(Area)),                 
                    {CenterPoint , Radius , Clockwise}
            end
    end.          

getAng({X1,Y1} , {X2,Y2}) -> 
    math:atan2(Y2-Y1,X2-X1).

getDistance({X1,Y1} , {X2,Y2}) ->
    math:sqrt(math:pow(Y2-Y1,2) + math:pow(X2-X1,2)).
	
